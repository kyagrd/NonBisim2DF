% vim: sw=2: ts=2: expandtab: ai:

% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage[utf8]{inputenc}
% \usepackage{makeidx}  % allows for indexgeneration
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{semantic}
\usepackage{listings}
\usepackage{hyperref}
%
\begin{document}
%
% \mainmatter              % start of the contributions
%

\title{Extracting Distinguishing Formulae from Bisimulation Tests for Finite Process Calculi}
%
\titlerunning{Distinguishing Formulae from Bisimulation Tests}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Authors BLINDED % Ki Yung Ahn \and Ross Horne \and Alwen Tiu
}
%
\authorrunning{Authors BLINDED % KY Ahn et al.
} % abbreviated author list (for running head)
%
%% %%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%
\institute{Institutes BLINDED % Nanyang Technological University, Singapore
}

\maketitle              % typeset the title of the contribution
\begin{abstract}
We study a problem of providing a certificate for two non-bisimilar processes
from a failed bisimulation test. Such a certificate is helpful for detecting
false-negative bugs and also for enhancing user experience of the tools based
on process equivalence checking. Our approach is to have the bisimulation test
provide a graph that logs the visited pairs of process states during the test,
regardless of whether the test succeeds or fails. This graph is
a generalization of a bisimulation relation, which is only defined for
bisimilar processes, that is when the test succeeds. From a graph with
a disproved root node, one can extract a modal logic formula, known as
the distinguishing formula, that satisfied by one process but not by the other.
Our approach requires little modification to existing bisimulation testing
algorithms (or procedures) and is also flexible to be extended for systems
with infinite states.
\keywords{bisimulation, process calculus, process algebra, process equivalence,
labeled transition systems, modal logic, distinguishing formula,
logic programming, tabling, model checking
}
\end{abstract}

\section{Introduction}\label{sec:intro}

We study a problem of providing a certificate for two non-bisimilar processes,
assuming a procedure for bisimulation test has already been implemented.
The problem with such an assumption is realistic within various tools [TODO cite]
equipped with equivalence checking features based on bisimulation.
Providing a certificate for failure has two benefits. First, false negatives
can be detected by a checker independent from the bisimulation test procedure.
Second, users are provided with useful information to analyze why
the processes are not equivalent when the test fails, which occurs very
frequently in practice. A typical usage scenario would involve
(a) defining a \emph{specification} process preferably with a simple structure
    that clearly describes its desired properties and
(b) testing for equivalence of an \emph{instance} process that is closer to
    an actual implementation against the specification.
In practice, it takes many iterations of (a) and (b) to develop a correct
specification that abstracts the essence of the system and to refine
the instance to match the specification being developed, which amounts to
numerous failures before a few successful bisimulation tests.

TODO Our contribution TODO

Our approach requires the bisimulation test to produce
a \emph{bisimulation testing graph} (in abbr., \emph{bisim-graph}),
which is a generalization of the \emph{bisimulation set}
(in abbr., \emph{bisim-set}) (a.k.a., bisimulation relation),
so that one can extract a \emph{distinguishing formula} from that graph
when the test fails.
By definition of the bisim-set, it is natural to assume that bisimulation
testing procedures should be able produce a bisim-set ($R \subset S\times S$),
which is a set of process state pairs, when the test succeeds.
In principle, this set $R$ has enough information to serve as a proof
certificate for a pair of bisimilar processes. More generally, to produce
a disproof certificate as well, we require that the bisimulation test
to produce a bisim-graph $G=(V,E)$ whose vertexes
($V\subset\{\texttt{p},\texttt{d}\}\times(S\times S)$) are process state pairs
with an additional tag whether the two process states ($p, q\in S$) are proved
($\texttt{p}(p,q)$) or disproved ($\texttt{d}(p,q)$) to be bisimilar and edges
are common transitions (or actions) over process state pairs
$(E\subset(S\times S)\times A\times(S\times S))$ where
$(p,q)\xrightarrow{\pi}(p',q') \in E$ means that both $p\xrightarrow{\pi}p'$
and $q\xrightarrow{\pi}q'$. Intuitively, the bisim-graph $G=(V,E)$ logs
the information of process state pairs visited during the bisimulation test
along with their transition steps. When the test succeeds,
the subset of $V$ consisting of only the proved pairs, ignoring their tags,
($\{(p,q) \mid \texttt{p}(p,q)\in V\}$) exactly corresponds to the bisim-set.
When the test fails, the bisim-graph provides enough information to
construct a \emph{distinguishing formula} $\varphi_{(p,q)}$ such that
$p |= \varphi_{(p,q)}$ but $q \not{|=} \varphi_{(p,q)}$ in a modal logic
known to be adequate for characterizing bisimilar processes.

TODO Our method TODO
and 
two processes are
bisimulation testing procedure

%% states are represented as terms in process calculi that evolve by tacking
%% next possible action rather than transitions over predetermined set of
%% process states as in traditional LTS-style presentations.

\paragraph{} TODO contributions and how we approach??\\
Hennessy--Milner Logic (HML) is known to be \emph{adequate}
labeled transition systems TODO TODO

\paragraph{} TODO paper organization and future work???

\section{Bisim-Graphs for Finite CCS} \label{sec:ccsbisim}

% \begin{figure}
\begin{align*}
&\text{Syntax} &
p,q,r &::= 0 \mid \pi.p \mid p + q \mid p|q \mid (\nu a)p \\ &&
\pi &::= a \mid \bar{a} \mid \tau
\\
&\text{Semantics} &
\tau.p &\xrightarrow{\tau} p \\ &&
a.p &\xrightarrow{\downarrow a} p \\ &&
\bar{a}.p &\xrightarrow{\uparrow a} p \\ &&
p+q &\xrightarrow{\pi} p' \qquad\text{when}\quad p \xrightarrow{\pi} p' \\ &&
p+q &\xrightarrow{\pi} q' \qquad\text{when}\quad q \xrightarrow{\pi} q' \\ &&
p|q &\xrightarrow{\pi} p'|q ~~\quad\text{when}\quad p \xrightarrow{\pi} p' \\ &&
p|q &\xrightarrow{\pi} p|q' ~~\quad\text{when}\quad q \xrightarrow{\pi} q' \\ &&
p|q &\xrightarrow{\tau} p'|q' ~\;\quad\text{when}\quad
  p \xrightarrow{\uparrow a} p' ~\text{and}~
  q \xrightarrow{\downarrow a} q' \\ &&
p|q &\xrightarrow{\tau} p'|q' ~\;\quad\text{when}\quad
  p \xrightarrow{\downarrow a} p' ~\text{and}~
  q \xrightarrow{\uparrow a} q' \\ &&
(\nu a)p &\xrightarrow{\tau} (\nu a)p' \quad\text{when}\quad
  p \xrightarrow{\pi} p' ~\text{and}~ \pi \notin \{\downarrow a, \uparrow a\}
\end{align*}
% \vspace*{-4ex}
% \caption{Syntax and Semantics of Finite CCS}
% \label{fig:ccsdef}
% \end{figure}


\begin{figure}
\begin{verbatim}
Define one : p -> a -> p -> prop
by one (taup P) tau P
 ; one (inp X P) (dn X) P
 ; one (out X P) (up X) P
 ; one (plus P Q) A R := one P A R
 ; one (plus P Q) A R := one Q A R
 ; one (par P Q) A (par P1 Q) := one P A P1
 ; one (par P Q) A (par P Q1) := one Q A Q1
 ; one (par P Q) tau (par P1 Q1) :=
     exists X, one P (up X) P1 /\ one Q (dn X) Q1
 ; one (par P Q) tau (par P1 Q1) :=
     exists X, one P (dn X) P1 /\ one Q (up X) Q1
 ; one (new P) A (new Q) := nabla x, one (P x) A (Q x)
 .
Define coinductive bisim : p -> p -> prop
by bisim P P % shortcut for obvious case
 ; bisim P Q :=
      (forall P1 X, one P X P1 -> exists Q1, one Q X Q1 /\ bisim P1 Q1)
   /\ (forall Q1 X, one Q X Q1 -> exists P1, one P X P1 /\ bisim P1 Q1)
 .
\end{verbatim}
\vspace*{-4ex}
\caption{Bedwyr Definitions of the Labeled Semantics and Bisimulation for finite CCS}
\label{fig:ccsone}
\end{figure}


\begin{figure}
\begin{verbatim}
Define coinductive bisim : p -> p -> prop
     % bisim_step* below are for tabling edges of bisim-graph
     , bisim_step : p -> p -> a -> p -> p -> prop
     , bisim_step_1st : p -> p -> a -> p -> prop
     , bisim_step_2nd : p -> p -> a -> p -> prop
     , bisim_step_label : p -> p -> a -> prop
     , coinductive bisim_step_tbl : nat -> p -> p -> a -> p -> p -> prop
by bisim P P % shortcut for obvious case
 ; bisim P Q :=
      (forall P1 X, one P X P1 -> exists Q1, one Q X Q1
                              /\ bisim_step P Q X P1 Q1 /\ bisim P1 Q1)
   /\ (forall Q1 X, one Q X Q1 -> exists P1, one P X P1
                              /\ bisim_step P Q X P1 Q1 /\ bisim P1 Q1)
 ; bisim_step_tbl N P Q X P1 Q1   % always succeeds when called
 ; bisim_step P Q X P1 Q1 := bisim_step_tbl 0 P Q X P1 Q1
                          /\ bisim_step_1st P Q X P1
                          /\ bisim_step_2nd P Q X Q1
                          /\ bisim_step_label P Q X
 ; bisim_step_1st P Q X P1 := bisim_step_tbl 1 P Q X P1 null
 ; bisim_step_2nd P Q X Q1 := bisim_step_tbl 2 P Q X null Q1
 ; bisim_step_label P Q X := bisim_step_tbl 3 P Q X null null
 .
\end{verbatim}
\label{fig:ccsbisim}
\end{figure}

\section{Distinguishing Formula from Bisim-Graphs}\label{sec:ccsdf}
Hennessy-Milner Logic
\begin{align*}
&\text{Syntax} &
\varphi & ::= \texttt{tt} \mid \texttt{ff}
    \mid \varphi \land \varphi \mid \varphi \lor \varphi
    \mid \langle\pi\rangle \varphi \mid \lbrack\pi\rbrack \varphi
\\
&\text{Semantics} &
  p & |= \top \\&&
  p & |= \varphi_1 \land \varphi_2 \quad\text{when}\quad p |= \varphi_1 ~~\text{and}~~ p |= \varphi_2 \\&&
  p & |= \varphi_1 \lor \varphi_2 \quad\text{when}\quad p |= \varphi_1 ~~~\text{or}~~~ p |= \varphi_2 \\&&
  p & |= \langle \pi \rangle \varphi \quad\text{when}\quad \forall q,~ p\xrightarrow{\pi} q ~\;\text{implies}~\; q |= \varphi \\&&
  p & |= \lbrack \pi \rbrack \varphi \;\quad\text{when}\quad \exists q,~ p\xrightarrow{\pi} p ~\quad\text{and}\quad\; q |= \varphi \\&&
\end{align*}

\begin{verbatim}
Define satisfy : p -> o' -> prop
by satisfy P tt := true
 ; satisfy P ff := false
 ; satisfy P (conj A B) := satisfy P A /\ satisfy P B
 ; satisfy P (disj A B) := satisfy P A \/ satisfy P B
 ; satisfy P (dia X A) := exists Q, one P X Q /\ satisfy Q A
 ; satisfy P (box X A) := forall Q, one P X Q -> satisfy Q A
 .
\end{verbatim}

\begin{figure}
\begin{verbatim}
Define tbl_bisim_step : p -> p -> a -> p -> p -> prop
     , tbl_bisim_step_1st : p -> p -> a -> p -> prop
     , tbl_bisim_step_2nd : p -> p -> a -> p -> prop
     , tbl_bisim_step_label : p -> p -> a -> prop
by tbl_bisim_step P Q X P1 Q1 := proved' bisim_step_tbl 0 P Q X P1 Q1
 ; tbl_bisim_step_1st P Q X P1 := proved' bisim_step_tbl 1 P Q X P1 null
 ; tbl_bisim_step_2nd P Q X Q1 := proved' bisim_step_tbl 2 P Q X null Q1
 ; tbl_bisim_step_label P Q X := proved' bisim_step_tbl 3 P Q X null null
 .

Define disform : p -> p -> option o' -> prop
by disform P Q F :=
   _if (proved bisim P Q)
       (F = opnone)
       (_if (disproved bisim P Q)
            (  nextlabels P Xs /\ nextlabels Q Ys
            /\ setminus Xs Ys Xs_Ys /\ setminus Ys Xs Ys_Xs
            /\ _if (det_mem X1 Xs_Ys) (F = opsome (dia X1 tt)) (
               _if (det_mem Y1 Ys_Xs) (F = opsome (box Y1 ff)) (
               enum (tbl_bisim_step_label P Q) Zs
            /\ (det_or (det_or
                (exists Z P1s P1 Q1s OFs Fs F1, member Z Zs
                /\ enum (tbl_bisim_step_1st P Q Z) P1s /\ member P1 P1s
                /\ enum (tbl_bisim_step P Q Z P1) Q1s
                /\ map (disform P1) Q1s OFs
                /\ map some Fs OFs /\ all_o' Fs F1 /\ F = opsome (dia Z F1) )
                %
                (exists Z P1s P1 Q1s OFs Fs F1, member Z Zs
                /\ enum (tbl_bisim_step_2nd P Q Z) Q1s /\ member Q1 Q1s 
                /\ enum (p\ tbl_bisim_step P Q Z p Q1) P1s
                /\ map (p\ disform p Q1) P1s OFs
                /\ map some Fs OFs /\ any_o' Fs F1 /\ F = opsome (box Z F1) )
                %
               ) (F = opnone) )
            ) ) )
            ( println "ERROR: neither in proved nor in disproved bisim table"
            /\ println P /\ println Q /\ false )
       )
  .


Define chk_disform : p -> p -> o' -> prop
by chk_disform P1 P2 G := disform P1 P2 (opsome F) /\ const_fold_o' F G
                       /\ satisfy P1 G /\ _not (satisfy P2 G).
\end{verbatim}
\end{figure}



\section{Finite $\pi$-calculus}\label{sec:pic}
\begin{align*}
\pi &::= a(x) \mid \bar a\langle b \rangle  \mid\tau
\end{align*}

\section{Discussions}
TODO
\subsection{Systems with Infinite States}
papers to cite


\section{Related Work}


\paragraph{TODO references here}
A framework for proof certificates in finite state exploration\\
\url{http://dx.doi.org/10.4204/EPTCS.186.4}

Algebraic laws for nondeterminism and concurrency\\
\url{http://dx.doi.org/10.1145/2455.2460}

Proof Search Specifications of Bisimulation and Modal Logics for the $\pi$-calculus\\
\url{https://arxiv.org/abs/0805.2785}

\begin{verbatim}
"Modal logics for mobile processes", by R. Milner, J. Parrow and D. Walker
Theoretical Computer Science 114 (1993).
\end{verbatim}
\end{document}

